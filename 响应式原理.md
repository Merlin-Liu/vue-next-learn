# vue3.0 响应式原理

vue3使用proxy代替defineProperty实现数据的响应式，打开源码，一眼看出在reactivity目录。

## 用法

vue3的响应式单独独立出一个模块，可以脱离其他模块使用。

点开reactivity，reactive、ref、effect、computed勉强能看出是什么意思，但是怎么用呢，看单测。

结合单测，简单知道了vue3的响应式如何使用，简单用法如下，不懂的话多看看单测吧，不赘述。

```
import { reactive, effect } from 'vue'

const state = reactive({ name: 'vue3' })

effect(() => {
  console.log('第1⃣️个effect', state.name)
})
effect(() => {
  console.log('第2⃣️个effect', state.name)
})

state.name = 'react16'
```

使用reactive定义一个响应式数据，使用effect监听数据的变更，并执行相关的操作，effect在初始化的时候会执行一次。

即代码的输出结果为：

```
第1⃣️个effect vue3
第2⃣️个effect vue3
第1⃣️个effect react16
第2⃣️个effect react16
```

## reacive

先看reactive.ts，其他的先不用看，直接看`reacive`方法，阅读源码切忌一行一行读。

```
const rawToReactive = new WeakMap<any, any>()
const reactiveToRaw = new WeakMap<any, any>()
  
export function reactive(target: object) {
  if (readonlyToRaw.has(target)) {
    return target
  }
  
  if (readonlyValues.has(target)) {
    return readonly(target)
  }
  return createReactiveObject(
    target,
    rawToReactive,
    reactiveToRaw,
    mutableHandlers,
    mutableCollectionHandlers
  )
}
```
`reactive`方法之所以返回一个`createReactiveObject`函数的原因是：如果reactive的对象是readonly的，则需对其进行相关处理，使`reactive`方法兼容对象是否为readonly的情况。

### createReactiveObject

readonly的情况后续分析，目前只关注核心，直接看`createReactiveObject`方法，其实不了解typeScript也勉强能看懂，typeScript只是标注了类型。

```
  function createReactiveObject(target, toProxy, toRaw, baseHandlers, collectionHandlers) {
    if (!isObject(target)) {
      return target
    }

    // target已经被代理过了
    let observed = toProxy.get(target)
    if (observed !== void 0) {
      return observed
    }

    // target是个proxy
    if (toRaw.has(target)) {
      return target
    }

    // readoly的情况，后续分析
    const handlers = collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers

    observed = new Proxy(target, handlers)

    toProxy.set(target, observed)
    toRaw.set(observed, target)

    if (!targetMap.has(target)) {
      targetMap.set(target, new Map())
    }
    
    return observed
  }
```

代码稍微有简化，首先`createReactiveObject`方法处理了入参不是对象的情况。

接下来，就是重点了，考虑如下两种情况

```
import { reactive } from 'vue'

// 情况1
const stateA = reactive({ name: '1111' })
const stateB = reactive({ name: '1111' })
const stateC = reactive({ name: '1111' })

// 情况2
const proxyA = reactive({ name: '1111' })
const proxyB = reactive(proxyA)
const proxyC = reactive(proxyB)
```

1. 同一个数据（对象）被多次代理
2. 代理对象被代理

上面两种情况是没有意义的，我们不希望他们出现，所以vue3先定义了两个`WeakMap`在`reactive.ts`中，分别是`rawToReactive`、`reactiveToRaw`，他们分别是用来存储target（原对象）和proxy（代理对象）的关系的。

`rawToReactive`顾名思义，存储的应该是target和proxy的映射关系，以target作为weakMap的`key`，proxy作为weakMap的`val`。

`reactiveToRaw`则反之，存储的应该是proxy和target的映射关系，以proxy作为weakMap的`key`，target作为weakMap的`val`。

好了，看代码，处理完入参不是对象的情况后，取target对proxy的映射即`rawToReactive`，如果rawToReactive存在target对应的proxy，证明target已经被代理过了，这时候只要返回代理target的proxy就好了。

如果rawToReactive不存在target对应的proxy，则target还没被代理过，进行下一轮判断，判断proxy对target的映射即`reactiveToRaw`中是否存在target的key，如果有的话，证明target是个代理对象，那么就将代理对象返回就好了。