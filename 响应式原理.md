# vue3.0 响应式原理

vue3使用proxy代替defineProperty实现数据的响应式，打开源码，一眼看出在reactivity目录。

## 用法

vue3的响应式单独独立出一个模块，可以脱离其他模块使用。

点开reactivity，reactive、ref、effect、computed勉强能看出是什么意思，但是怎么用呢，看单测。

结合单测，简单知道了vue3的响应式如何使用，简单用法如下，不懂的话多看看单测吧，不赘述。

```
import { reactive, effect } from 'vue'

const state = reactive({name: 'vue3'})

effect(() => {
  console.log('第1⃣️个effect', state.name)
})
effect(() => {
  console.log('第2⃣️个effect', state.name)
})

state.name = 'react16'
```

使用reactive定义一个响应式数据，使用effect监听数据的变更，并执行相关的操作，effect在初始化的时候会执行一次。

即代码的输出结果为：

```
第1⃣️个effect vue3
第2⃣️个effect vue3
第1⃣️个effect react16
第2⃣️个effect react16
```

## reacive

先看reactive.ts，其他的先不用看，直接看`reacive`方法，阅读源码切忌一行一行读。

```
export function reactive(target: object) {
  if (readonlyToRaw.has(target)) {
    return target
  }
  
  if (readonlyValues.has(target)) {
    return readonly(target)
  }
  return createReactiveObject(
    target,
    rawToReactive,
    reactiveToRaw,
    mutableHandlers,
    mutableCollectionHandlers
  )
}
```

`reactive`方法之所以返回一个`createReactiveObject`函数的原因是：如果reactive的对象是readonly的，则需对其进行相关处理，使`reactive`方法兼容对象是否为readonly的情况。

